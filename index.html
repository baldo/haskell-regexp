<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Weighted RegExp Matching</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<h1 class="title">Weighted RegExp Matching</h1>
<div id="TOC"
><ul
  ><li
    ><a href="#background"
      >Background</a
      ></li
    ><li
    ><a href="#installation"
      >Installation</a
      ></li
    ><li
    ><a href="#correctness"
      >Correctness</a
      ></li
    ><li
    ><a href="#performance"
      >Performance</a
      ></li
    ><li
    ><a href="#development"
      >Development</a
      ></li
    ></ul
  ></div
>
<p
>Efficient regular expression matching can be beautifully simple. Revisiting ideas from theoretical computer science, it can be implemented with linear worst-case time and space bounds in the purely functional programming language <a href="http://hackage.haskell.org/platform/"
  >Haskell</a
  >.</p
><h1 id="background"
><a href="#TOC"
  >Background</a
  ></h1
><p
>Since Plato wrote about philosophy in the form of <a href="http://en.wikipedia.org/wiki/Socratic_dialogue"
  >dialogues</a
  >, authors have used this literary form in didactic writing to convey their ideas. The 15th <a href="http://www.icfpconference.org/icfp2010/"
  >International Conference on Functional Programming</a
  > features an article on Regular Expressions written as a play, <a href="regexp-play.pdf"
  >A Play on Regular Expressions</a
  >, which is meant to be <a href="http://web.cecs.pdx.edu/~apt/icfp09_cfp.html#pearls"
  >elegant, instructive, and fun</a
  >. The play discusses an efficient, purely functional algorithm for matching regular expressions. By generalizing from Booleans to arbitrary <a href="http://en.wikipedia.org/wiki/Semiring"
  >semirings</a
  >, this algorithm implements various matching policies for weighted regular expressions.</p
><h1 id="installation"
><a href="#TOC"
  >Installation</a
  ></h1
><p
>An implementation of the ideas discussed in the Play on Regular Expressions is available as a Haskell library. It is implemented in pure Haskell rather than as a binding to an external library so you do not need to install an external regular expression library to use it.</p
><table class="installation">

<tr><td>
<p
><a href="http://hackage.haskell.org/platform"
  ><img src="http://hackage.haskell.org/platform/icons/button-100.png" alt="Download Haskell"
     /></a
  ></p
></td><td>
<p
>However, you need Haskell in order to use this library. By installing the <a href="http://hackage.haskell.org/platform/"
  >Haskell Platform</a
  > you get a Haskell compiler with an interactive environment as well as the package manager <code
  >cabal-install</code
  > and various pre-installed packages.</p
></td></tr><tr><td>
<img src="http://hackage.haskell.org/images/Cabal-light.png" alt="Cabal" width="195" height="71" /></td><td>
<p
>You can install the weighted regexp library by typing the following into a terminal:</p
><pre
><code
  >bash# cabal update
bash# cabal install weighted-regexp
</code
  ></pre
></td></tr>

</table>
<h1 id="correctness"
><a href="#TOC"
  >Correctness</a
  ></h1
><p
>The matching algorithm computes the same result as a simple inductive specification (given in the <a href="regexp-play.pdf"
  >Play on Regular Expressions</a
  >) but is <a href="#performance"
  >more efficient</a
  > than a direct translation of this specification into Haskell. Although the ideas behind the algorithm are not new but based on proven results from theoretical computer science, there is no correctness proof for the equivalence of the Haskell implementation of the algorithm with its specification. It is therefore confirmed using tests.</p
><p
>Is difficult (and tedious) to write tests manually that cover all interesting apsects of regular expression matching. Fortunately, <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/"
  >QuickCheck</a
  > helps to generate such tests automatically and <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/hpc.html"
  >Haskell Program Coverage (HPC)</a
  > can be used to monitor test coverage.</p
><p
>You can install the <code
  >weighted-regexp</code
  > library along with a test program as follows:</p
><pre
><code
  >bash# cabal install weighted-regexp -fQuickCheck
</code
  ></pre
><p
>Using the <code
  >QuickCheck</code
  > flag results in an additional program that you can use to test the implementation. It will test</p
><ul
><li
  ><p
    >the algebraic laws of semirings for all defined semirings,</p
    ></li
  ><li
  ><p
    >the equivalence of the matching algorithm with the specification both for full and partial matchings.</p
    ></li
  ></ul
><p
>Moreover, it will test</p
><ul
><li
  ><p
    >the parser that provides common syntactic sugar like bounded repetitions and character classes, and</p
    ></li
  ><li
  ><p
    >the use of the library to recognize non-regular languages using infinite regular expressions.</p
    ></li
  ></ul
><p
>In order to generate an HPC report you need to download the sources of the <code
  >weighted-regexp</code
  > package. But you may as well consult the <a href="quickcheck/hpc_index.html"
  >pregenerated coverage report</a
  > instead of generating it yourself.</p
><h1 id="performance"
><a href="#TOC"
  >Performance</a
  ></h1
><h1 id="development"
><a href="#TOC"
  >Development</a
  ></h1
>
</body>
</html>
